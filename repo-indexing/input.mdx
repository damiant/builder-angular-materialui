# Input Components

## Overview

### Purpose

Use this component to generate input field functionality

### When to Use

Input components are essential for collecting user data and enabling interactive forms throughout your application. Use them when you need to:

- **Data collection** - Gather text, numbers, emails, passwords, and other user input in forms and dialogs
- **Search functionality** - Create search bars, filter inputs, and query interfaces for content discovery
- **User authentication** - Build login forms, registration forms, and password reset interfaces
- **Content creation** - Enable users to write posts, comments, messages, or any text-based content
- **Settings and preferences** - Allow users to configure application settings, profile information, and personal preferences
- **Data editing** - Provide inline editing capabilities for tables, lists, and content management interfaces
- **Real-time input** - Create live search, autocomplete, and instant feedback experiences
- **Multi-step forms** - Build complex workflows that require user input across multiple steps
- **Contact forms** - Collect user inquiries, feedback, support requests, and contact information
- **E-commerce transactions** - Gather shipping addresses, payment information, and order details
- **Content filtering** - Enable users to filter large datasets, tables, and search results

### Architecture

**No Coupling**: The Input component is a standalone directive that enhances native HTML input and textarea elements. It works independently but integrates seamlessly with Angular Material's FormField component for enhanced functionality and consistent styling.

### Component Interdependencies

The Input component demonstrates no coupling as it is a standalone directive that:

- **Direct application**: Can be applied to any native HTML input or textarea element using the `matInput` directive
- **FormField integration**: Optionally works within `mat-form-field` for enhanced styling, labeling, and error handling
- **Form integration**: Seamlessly integrates with Angular Reactive Forms and Template-driven Forms
- **Accessibility enhancement**: Automatically handles ARIA attributes and accessibility features

## Components

### MatInput {Standalone Component}

A directive that enhances native HTML input and textarea elements with Material Design styling, accessibility features, and seamless integration with Angular Material components.

**Purpose:** Transforms standard HTML input and textarea elements into Material Design-compliant form controls with proper styling, validation states, focus management, and accessibility support.

**Interface:**

```typescript
interface MatInputDirective {
  // Core Properties
  disabled: boolean; // Controls whether the input is disabled
  id: string; // Sets the ID attribute of the input element
  placeholder: string; // Placeholder text displayed when input is empty
  name: string; // Name attribute for form submission
  required: boolean; // Indicates if the input is required for form validation
  readonly: boolean; // Specifies if the input is read-only
  value: string | number; // Current value of the input element
  type: string; // Input type (text, email, password, number, etc.)

  // Validation and Error Handling
  errorStateMatcher: ErrorStateMatcher; // Custom error state logic
  userAriaDescribedBy: string; // Additional ARIA descriptions

  // Events
  focus(options?: FocusOptions): void; // Programmatically focus the input
  updateErrorState(): void; // Update error state based on validation
}

interface ErrorStateMatcher {
  isErrorState(
    control: FormControl | null,
    form: FormGroupDirective | NgForm | null,
  ): boolean;
}
```

**Usage Example:**

```tsx
import { MatInputModule } from "@angular/material/input";
import { MatFormFieldModule } from "@angular/material/form-field";

// Basic input with FormField
function BasicInputExample() {
  return (
    <mat-form-field>
      <mat-label>Enter your name</mat-label>
      <input matInput placeholder="John Doe" />
    </mat-form-field>
  );
}

// Input with validation
function ValidatedInputExample() {
  return (
    <mat-form-field>
      <mat-label>Email Address</mat-label>
      <input
        matInput
        type="email"
        placeholder="user@example.com"
        required
        formControlName="email"
      />
      <mat-error *ngIf="emailControl.hasError('required')">
        Email is required
      </mat-error>
      <mat-error *ngIf="emailControl.hasError('email')">
        Please enter a valid email
      </mat-error>
    </mat-form-field>
  );
}

// Standalone input without FormField
function StandaloneInputExample() {
  return (
    <input
      matInput
      placeholder="Search..."
      (input)="onSearch($event)"
      class="search-input"
    />
  );
}
```

## Integration Patterns

### Basic Text Input

```tsx
import { MatInputModule } from "@angular/material/input";
import { MatFormFieldModule } from "@angular/material/form-field";

// Simple text input with label
function BasicTextInput() {
  return (
    <mat-form-field appearance="outline">
      <mat-label>Full Name</mat-label>
      <input matInput placeholder="Enter your full name" />
    </mat-form-field>
  );
}
```

### Reactive Forms Integration

```tsx
import { FormControl, FormGroup, Validators } from "@angular/forms";

// Integration with Angular Reactive Forms
function ReactiveFormExample() {
  const userForm = new FormGroup({
    firstName: new FormControl("", [Validators.required, Validators.minLength(2)]),
    email: new FormControl("", [Validators.required, Validators.email]),
    phone: new FormControl("", [Validators.pattern(/^\d{10}$/)]),
  });

  return (
    <form [formGroup]="userForm">
      <mat-form-field>
        <mat-label>First Name</mat-label>
        <input matInput formControlName="firstName" required />
        <mat-error *ngIf="userForm.get('firstName')?.hasError('required')">
          First name is required
        </mat-error>
        <mat-error *ngIf="userForm.get('firstName')?.hasError('minlength')">
          Name must be at least 2 characters
        </mat-error>
      </mat-form-field>

      <mat-form-field>
        <mat-label>Email</mat-label>
        <input matInput type="email" formControlName="email" required />
        <mat-error *ngIf="userForm.get('email')?.hasError('required')">
          Email is required
        </mat-error>
        <mat-error *ngIf="userForm.get('email')?.hasError('email')">
          Please enter a valid email
        </mat-error>
      </mat-form-field>

      <mat-form-field>
        <mat-label>Phone Number</mat-label>
        <input matInput type="tel" formControlName="phone" />
        <mat-error *ngIf="userForm.get('phone')?.hasError('pattern')">
          Please enter a valid 10-digit phone number
        </mat-error>
      </mat-form-field>
    </form>
  );
}
```

### Advanced Input Variations

```tsx
// Password input with visibility toggle
function PasswordInputExample() {
  const [hidePassword, setHidePassword] = useState(true);

  return (
    <mat-form-field>
      <mat-label>Password</mat-label>
      <input
        matInput
        [type]="hidePassword ? 'password' : 'text'"
        formControlName="password"
        required
      />
      <button
        mat-icon-button
        matSuffix
        (click)="hidePassword = !hidePassword"
        [attr.aria-label]="'Hide password'"
        [attr.aria-pressed]="hidePassword"
      >
        <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
      </button>
    </mat-form-field>
  );
}

// Textarea with character counter
function TextareaExample() {
  return (
    <mat-form-field>
      <mat-label>Description</mat-label>
      <textarea
        matInput
        placeholder="Tell us about yourself"
        rows="4"
        maxlength="500"
        formControlName="description"
      ></textarea>
      <mat-hint align="end">{{description.value?.length || 0}}/500</mat-hint>
    </mat-form-field>
  );
}

// Search input with clear button
function SearchInputExample() {
  return (
    <mat-form-field appearance="outline">
      <mat-label>Search</mat-label>
      <input
        matInput
        placeholder="Search products..."
        formControlName="search"
        (input)="onSearch($event)"
      />
      <button
        mat-icon-button
        matSuffix
        *ngIf="searchControl.value"
        (click)="clearSearch()"
        aria-label="Clear search"
      >
        <mat-icon>clear</mat-icon>
      </button>
    </mat-form-field>
  );
}
```

## Common Patterns

### Pattern 1: Form Field Integration

```tsx
// Recommended pattern for most input usage
// Always wrap inputs in mat-form-field for consistent styling and functionality
<mat-form-field appearance="outline">
  <mat-label>Field Label</mat-label>
  <input matInput placeholder="Placeholder text" formControlName="fieldName" />
  <mat-hint>Helper text for the user</mat-hint>
  <mat-error *ngIf="fieldControl.hasError('required')">
    This field is required
  </mat-error>
</mat-form-field>
```

### Pattern 2: Input Type Variations

```tsx
// Use appropriate input types for better UX and validation
<mat-form-field>
  <mat-label>Email</mat-label>
  <input matInput type="email" formControlName="email" />
</mat-form-field>

<mat-form-field>
  <mat-label>Phone</mat-label>
  <input matInput type="tel" formControlName="phone" />
</mat-form-field>

<mat-form-field>
  <mat-label>Age</mat-label>
  <input matInput type="number" min="1" max="120" formControlName="age" />
</mat-form-field>

<mat-form-field>
  <mat-label>Website</mat-label>
  <input matInput type="url" formControlName="website" />
</mat-form-field>
```

### Pattern 3: Filter and Search Inputs

```tsx
// Standalone inputs for filtering and search functionality
// Often used outside of form-field for compact layouts
<input
  matInput
  placeholder="Filter items..."
  (input)="applyFilter($event)"
  class="filter-input"
/>

// With form-field for enhanced styling
<mat-form-field appearance="outline" class="search-field">
  <mat-label>Search</mat-label>
  <input
    matInput
    placeholder="Search products..."
    (input)="onSearch($event)"
  />
  <mat-icon matPrefix>search</mat-icon>
</mat-form-field>
```

## Best Practices

### Usage Guidelines

- **Always use with FormField**: Wrap inputs in `mat-form-field` for consistent styling, proper labeling, and error handling
- **Choose appropriate input types**: Use specific input types (email, tel, number, url) for better user experience and built-in validation
- **Provide clear labels**: Use `mat-label` for accessible, floating labels that describe the input purpose
- **Include helpful hints**: Use `mat-hint` to provide additional context or formatting requirements
- **Implement proper validation**: Always provide meaningful error messages using `mat-error` with specific validation states

### Accessibility

- **Automatic ARIA handling**: MatInput automatically manages ARIA attributes for screen reader compatibility
- **Label association**: Labels are properly associated with inputs for screen reader navigation
- **Error announcements**: Validation errors are announced to screen readers when they appear
- **Focus management**: Proper focus indicators and keyboard navigation support
- **Required field indication**: Use the `required` attribute and visual indicators for required fields

### Performance

- **Debounce search inputs**: For search and filter inputs, implement debouncing to avoid excessive API calls or filtering operations
- **Lazy validation**: Consider implementing validation on blur rather than on every keystroke for complex validation
- **Virtual scrolling**: For autocomplete with large datasets, implement virtual scrolling for better performance
- **Form state management**: Use reactive forms for complex forms with multiple inputs and interdependent validation

### Form Integration

- **Reactive Forms recommended**: Use Angular Reactive Forms for better control over validation and form state
- **Group related inputs**: Use `FormGroup` to group related inputs and manage their validation collectively
- **Custom validators**: Implement custom validators for business-specific validation rules
- **Error state matching**: Use `ErrorStateMatcher` for custom error display logic across different form states
- **Form submission handling**: Properly handle form submission and display loading states during async operations

## Common Use Cases

### User Authentication Forms

```tsx
// Login form with email and password
<form [formGroup]="loginForm" (ngSubmit)="onLogin()">
  <mat-form-field>
    <mat-label>Email</mat-label>
    <input matInput type="email" formControlName="email" required />
    <mat-error *ngIf="loginForm.get('email')?.hasError('required')">
      Email is required
    </mat-error>
    <mat-error *ngIf="loginForm.get('email')?.hasError('email')">
      Please enter a valid email
    </mat-error>
  </mat-form-field>

  <mat-form-field>
    <mat-label>Password</mat-label>
    <input matInput type="password" formControlName="password" required />
    <mat-error *ngIf="loginForm.get('password')?.hasError('required')">
      Password is required
    </mat-error>
  </mat-form-field>

  <button mat-raised-button type="submit" [disabled]="loginForm.invalid">
    Sign In
  </button>
</form>
```

### Data Entry and Editing

```tsx
// Inline editing in tables or lists
<mat-form-field *ngIf="editMode; else displayMode">
  <input
    matInput
    [(ngModel)]="item.name"
    (blur)="saveChanges()"
    (keyup.enter)="saveChanges()"
    (keyup.escape)="cancelEdit()"
  />
</mat-form-field>

<ng-template #displayMode>
  <span (click)="enterEditMode()">{{item.name}}</span>
</ng-template>
```

### Search and Filter Interfaces

```tsx
// Global search with instant results
<mat-form-field appearance="outline" class="search-container">
  <mat-label>Search</mat-label>
  <input
    matInput
    placeholder="Search products, categories, brands..."
    formControlName="globalSearch"
    (input)="onGlobalSearch($event)"
  />
  <mat-icon matPrefix>search</mat-icon>
  <button
    mat-icon-button
    matSuffix
    *ngIf="searchControl.value"
    (click)="clearSearch()"
  >
    <mat-icon>clear</mat-icon>
  </button>
</mat-form-field>
```
