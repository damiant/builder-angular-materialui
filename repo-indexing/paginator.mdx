# Paginator Components

## Overview

### Purpose

Use this component to generate paginator functionality

### When to Use

Paginator components are essential for managing large datasets and providing intuitive navigation controls for users. Use them when you need to:

- **Large dataset management** - Break down large collections of data into manageable, digestible pages to improve performance and user experience
- **Table pagination** - Provide navigation controls for data tables, allowing users to browse through rows efficiently without overwhelming the interface
- **Search result navigation** - Enable users to navigate through search results, product listings, or filtered content across multiple pages
- **Performance optimization** - Reduce initial load times and memory usage by loading data in smaller chunks rather than all at once
- **User experience enhancement** - Improve content discoverability by providing clear navigation paths through large content collections
- **List and grid pagination** - Add navigation controls to long lists, image galleries, or grid layouts for better content organization
- **API data management** - Coordinate with backend APIs that return paginated data, managing page requests and response handling
- **Mobile-friendly navigation** - Provide touch-friendly navigation controls that work well on smaller screens and mobile devices
- **Accessibility compliance** - Ensure screen reader users can efficiently navigate through large datasets with proper announcements
- **Data exploration** - Allow users to explore datasets systematically, with options to adjust how much data they view at once
- **Content browsing** - Enable users to browse through articles, posts, products, or any sequential content collections

### Architecture

**No Coupling**: The Paginator component is a standalone component that can be used independently to provide pagination controls for any dataset. It works seamlessly with Angular Material's Table component but can also be used with custom data display components or third-party libraries.

### Component Interdependencies

The Paginator component demonstrates no coupling as it operates independently while providing:

- **Flexible integration**: Can be connected to any data source or display component through event handling
- **Table integration**: Seamlessly integrates with MatTable and MatTableDataSource for automatic pagination
- **Custom data sources**: Works with any data structure through proper event handling and state management
- **Framework agnostic**: Core pagination logic can be adapted to work with different data presentation patterns

## Components

### MatPaginator {Standalone Component}

A comprehensive pagination component that provides navigation controls, page size selection, and data range information for managing large datasets with efficient user navigation.

**Purpose:** Provides intuitive pagination controls that allow users to navigate through large datasets, select page sizes, view current data ranges, and efficiently browse paginated content with full accessibility support.

**Interface:**

```typescript
interface MatPaginatorProps {
  // Data Configuration
  length: number; // Total number of items being paginated (required)
  pageSize: number; // Number of items to display per page (default: 50)
  pageIndex: number; // Zero-based index of the current page (default: 0)
  pageSizeOptions: number[]; // Array of available page size options (default: [])

  // UI Configuration
  showFirstLastButtons: boolean; // Show first and last page navigation buttons (default: false)
  hidePageSize: boolean; // Hide the page size selection dropdown (default: false)
  disabled: boolean; // Disable all pagination controls (default: false)

  // Theming
  color: "primary" | "accent" | "warn"; // Theme color for form controls

  // Accessibility
  selectConfig: MatPaginatorSelectConfig; // Configuration for page size select accessibility

  // Events
  page: EventEmitter<PageEvent>; // Emitted when page index or page size changes
}

interface PageEvent {
  length: number; // Total number of items being paginated
  pageIndex: number; // Zero-based index of the current page
  pageSize: number; // Number of items displayed per page
  previousPageIndex?: number; // Index of the previously selected page
}

interface MatPaginatorSelectConfig {
  disableOptionCentering?: boolean; // Disable centering of select options
  panelClass?: string | string[]; // CSS classes for the select panel
}

// Methods available on MatPaginator instance
interface MatPaginatorMethods {
  nextPage(): void; // Navigate to the next page
  previousPage(): void; // Navigate to the previous page
  firstPage(): void; // Navigate to the first page
  lastPage(): void; // Navigate to the last page
  hasNextPage(): boolean; // Check if there is a next page
  hasPreviousPage(): boolean; // Check if there is a previous page
  getNumberOfPages(): number; // Calculate total number of pages
}
```

**Usage Example:**

```tsx
import { MatPaginatorModule } from "@angular/material/paginator";
import { Component, ViewChild } from "@angular/core";

@Component({
  selector: "app-paginator-example",
  template: `
    <div class="data-container">
      <!-- Your data display component -->
      <div *ngFor="let item of paginatedData" class="data-item">
        {{ item.name }}
      </div>
    </div>

    <mat-paginator
      [length]="totalItems"
      [pageSize]="itemsPerPage"
      [pageIndex]="currentPage"
      [pageSizeOptions]="[10, 25, 50, 100]"
      [showFirstLastButtons]="true"
      (page)="onPageChange($event)"
      aria-label="Select page"
    >
    </mat-paginator>
  `,
})
export class PaginatorExample {
  @ViewChild(MatPaginator) paginator: MatPaginator;

  totalItems = 500;
  itemsPerPage = 25;
  currentPage = 0;
  paginatedData = [];

  onPageChange(event: PageEvent) {
    this.currentPage = event.pageIndex;
    this.itemsPerPage = event.pageSize;
    this.loadData();
  }

  loadData() {
    const startIndex = this.currentPage * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    // Load data for current page
    this.paginatedData = this.allData.slice(startIndex, endIndex);
  }
}
```

## Integration Patterns

### Table Integration

```tsx
import { MatTableModule } from "@angular/material/table";
import { MatPaginatorModule } from "@angular/material/paginator";

@Component({
  template: `
    <table mat-table [dataSource]="dataSource" class="mat-elevation-z8">
      <!-- Table columns -->
      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef>Name</th>
        <td mat-cell *matCellDef="let element">{{ element.name }}</td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>
    </table>

    <mat-paginator
      [pageSizeOptions]="[5, 10, 20]"
      showFirstLastButtons
      aria-label="Select page of users"
    >
    </mat-paginator>
  `,
})
export class TableWithPaginatorExample implements AfterViewInit {
  @ViewChild(MatPaginator) paginator: MatPaginator;

  dataSource = new MatTableDataSource(ELEMENT_DATA);
  displayedColumns: string[] = ["name", "weight", "symbol"];

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
  }
}
```

### Custom Data Source Integration

```tsx
@Component({
  template: `
    <div class="grid-container">
      <div *ngFor="let item of displayedItems" class="grid-item">
        <mat-card>
          <mat-card-content>{{ item.title }}</mat-card-content>
        </mat-card>
      </div>
    </div>

    <mat-paginator
      [length]="totalItems"
      [pageSize]="pageSize"
      [pageIndex]="currentPageIndex"
      [pageSizeOptions]="[12, 24, 48]"
      [showFirstLastButtons]="true"
      (page)="handlePageEvent($event)"
    >
    </mat-paginator>
  `,
})
export class CustomPaginatorExample {
  totalItems = 1000;
  pageSize = 12;
  currentPageIndex = 0;
  displayedItems: any[] = [];

  handlePageEvent(event: PageEvent) {
    this.totalItems = event.length;
    this.pageSize = event.pageSize;
    this.currentPageIndex = event.pageIndex;

    // Custom data loading logic
    this.loadPageData(event.pageIndex, event.pageSize);
  }

  loadPageData(pageIndex: number, pageSize: number) {
    const startIndex = pageIndex * pageSize;
    // Implement your data loading logic here
    this.displayedItems = this.fetchData(startIndex, pageSize);
  }
}
```

### Server-Side Pagination

```tsx
@Component({
  template: `
    <div class="search-results">
      <div *ngFor="let result of searchResults" class="result-item">
        {{ result.title }}
      </div>
    </div>

    <mat-paginator
      [length]="totalResults"
      [pageSize]="resultsPerPage"
      [pageIndex]="currentPage"
      [pageSizeOptions]="[10, 20, 50]"
      (page)="onPageChange($event)"
      [disabled]="loading"
    >
    </mat-paginator>
  `,
})
export class ServerPaginationExample {
  searchResults: any[] = [];
  totalResults = 0;
  resultsPerPage = 10;
  currentPage = 0;
  loading = false;

  onPageChange(event: PageEvent) {
    this.loading = true;
    this.currentPage = event.pageIndex;
    this.resultsPerPage = event.pageSize;

    // API call with pagination parameters
    this.searchService
      .getResults({
        page: event.pageIndex,
        size: event.pageSize,
      })
      .subscribe((response) => {
        this.searchResults = response.items;
        this.totalResults = response.totalCount;
        this.loading = false;
      });
  }
}
```

## Best Practices

### Usage Guidelines

- **Set meaningful page sizes**: Choose page size options that balance performance with user convenience (typically 10, 25, 50, 100)
- **Provide clear feedback**: Use loading states and proper error handling during data transitions between pages
- **Maintain page state**: Preserve user's current page and page size selection when navigating away and returning
- **Optimize for mobile**: Ensure pagination controls are touch-friendly and work well on smaller screens
- **Use appropriate defaults**: Set sensible default page sizes based on your content type and user needs
- **Handle edge cases**: Gracefully handle scenarios with no data, single pages, or dynamic data length changes

### Accessibility

- **Proper labeling**: Use descriptive `aria-label` attributes to help screen readers understand pagination purpose
- **Keyboard navigation**: Ensure all pagination controls are accessible via keyboard navigation with proper focus management
- **Screen reader announcements**: Provide clear announcements when page changes occur, including current page and total pages
- **Focus management**: Maintain logical focus order and return focus appropriately after page changes
- **ARIA live regions**: Use live regions to announce dynamic changes in page content for screen reader users

### Performance

- **Lazy loading**: Implement efficient data loading strategies that only fetch required page data
- **Caching strategy**: Cache previously loaded pages to improve navigation performance
- **Virtual scrolling**: Consider virtual scrolling for very large datasets as an alternative to traditional pagination
- **Debounced requests**: Implement request debouncing for rapid page size changes to avoid excessive API calls
- **Memory management**: Properly dispose of subscriptions and clean up resources when components are destroyed

## Common Patterns

### Pattern 1: Responsive Page Sizes

```tsx
@Component({
  template: `
    <mat-paginator
      [length]="totalItems"
      [pageSize]="getPageSize()"
      [pageSizeOptions]="getPageSizeOptions()"
      (page)="onPageChange($event)"
    >
    </mat-paginator>
  `,
})
export class ResponsivePaginatorExample {
  @HostListener("window:resize", ["$event"])
  onResize(event: any) {
    // Adjust page size based on screen size
    this.updatePageSizeForScreenSize();
  }

  getPageSize(): number {
    const screenWidth = window.innerWidth;
    if (screenWidth < 768) return 5; // Mobile
    if (screenWidth < 1024) return 10; // Tablet
    return 20; // Desktop
  }

  getPageSizeOptions(): number[] {
    const screenWidth = window.innerWidth;
    if (screenWidth < 768) return [5, 10]; // Mobile
    if (screenWidth < 1024) return [10, 20, 30]; // Tablet
    return [20, 50, 100]; // Desktop
  }
}
```

### Pattern 2: State Management Integration

```tsx
@Component({
  template: `
    <mat-paginator
      [length]="(paginationState$ | async)?.totalItems"
      [pageSize]="(paginationState$ | async)?.pageSize"
      [pageIndex]="(paginationState$ | async)?.currentPage"
      [pageSizeOptions]="[10, 25, 50]"
      (page)="onPageChange($event)"
    >
    </mat-paginator>
  `,
})
export class StateManagedPaginatorExample {
  paginationState$ = this.store.select(selectPaginationState);

  constructor(private store: Store) {}

  onPageChange(event: PageEvent) {
    this.store.dispatch(
      updatePagination({
        pageIndex: event.pageIndex,
        pageSize: event.pageSize,
      }),
    );

    this.store.dispatch(
      loadData({
        page: event.pageIndex,
        size: event.pageSize,
      }),
    );
  }
}
```

### Pattern 3: URL Synchronization

```tsx
@Component({
  template: `
    <mat-paginator
      [length]="totalItems"
      [pageSize]="pageSize"
      [pageIndex]="currentPage"
      (page)="onPageChange($event)"
    >
    </mat-paginator>
  `,
})
export class UrlSyncPaginatorExample implements OnInit {
  currentPage = 0;
  pageSize = 25;
  totalItems = 0;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
  ) {}

  ngOnInit() {
    // Read pagination state from URL parameters
    this.route.queryParams.subscribe((params) => {
      this.currentPage = +(params["page"] || 0);
      this.pageSize = +(params["size"] || 25);
      this.loadData();
    });
  }

  onPageChange(event: PageEvent) {
    // Update URL with new pagination state
    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: {
        page: event.pageIndex,
        size: event.pageSize,
      },
      queryParamsHandling: "merge",
    });
  }
}
```
