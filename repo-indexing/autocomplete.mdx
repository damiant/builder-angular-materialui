# Autocomplete Components

## Overview

### Purpose

Use this component to generate autocomplete functionality

### When to Use

Autocomplete components enhance user input by providing intelligent suggestions and rapid data entry capabilities. Use them when you need to:

- **Search functionality** - Create powerful search interfaces with real-time suggestions from large datasets
- **Data entry acceleration** - Speed up form completion by suggesting previously entered or common values
- **Selection assistance** - Help users choose from predefined options without requiring exact spelling or memory
- **API integration** - Connect to external services to provide dynamic suggestions based on user input
- **Complex form fields** - Enhance dropdowns and select fields with searchable, type-ahead functionality
- **User experience optimization** - Reduce typing effort and input errors through intelligent suggestions
- **Content discovery** - Enable users to find relevant content, tags, or categories quickly
- **Multi-language support** - Provide localized suggestions and support for international content
- **Address completion** - Implement location-based autocomplete for addresses and geographic data
- **Product catalogs** - Help users find products, services, or inventory items efficiently
- **Contact selection** - Enable quick selection of users, customers, or contacts from directories
- **Tag and category input** - Facilitate content organization through suggested tags and categories

### Architecture

**No Coupling**: The Autocomplete component is a standalone component that enhances input elements with dropdown suggestion panels. It works independently but integrates seamlessly with form fields, inputs, and other Angular Material components through directives and template references.

### Component Interdependencies

The Autocomplete component demonstrates no coupling as it is a standalone component that:

- **Direct integration**: Works with any input element through the `matAutocomplete` directive
- **Trigger directive**: Uses `MatAutocompleteTrigger` for programmatic control and event handling
- **Form field compatibility**: Seamlessly integrates with `mat-form-field` for consistent styling and behavior
- **Option management**: Works with `mat-option` components for displaying selectable choices
- **Input enhancement**: Enhances existing input fields without requiring component restructuring

## Components

### MatAutocomplete {Standalone Component}

A dropdown panel component that provides selectable options based on user input, enhancing form controls with intelligent suggestions and rapid data entry capabilities.

**Purpose:** Creates an overlay panel that displays filterable options, manages selection states, handles keyboard navigation, and integrates with form controls to provide autocomplete functionality for enhanced user experience.

**Interface:**

```typescript
interface MatAutocomplete {
  // Display Configuration
  displayWith: ((value: any) => string) | null; // Function to map option values to display text
  panelWidth: string | number; // Width of the autocomplete panel (auto-matches input width if not set)
  classList: string; // CSS classes applied to the overlay panel

  // Behavior Configuration
  autoActiveFirstOption: boolean; // Whether to highlight the first option automatically
  disableRipple: boolean; // Disables ripple animations on options
  hideSingleSelectionIndicator: boolean; // Hides checkmarks on single-selection options

  // State Properties
  id: string; // Unique identifier for the autocomplete panel
  isOpen: boolean; // Whether the autocomplete panel is currently open
  options: QueryList<MatOption>; // Collection of available options
  optionGroups: QueryList<MatOptgroup>; // Collection of option groups if using grouped options
  panel: ElementRef; // Reference to the overlay panel element

  // Events
  opened: EventEmitter<void>; // Emitted when panel opens
  closed: EventEmitter<void>; // Emitted when panel closes
  optionSelected: EventEmitter<MatAutocompleteSelectedEvent>; // Emitted when option is selected
  optionActivated: EventEmitter<MatAutocompleteActivatedEvent>; // Emitted when option is highlighted via keyboard
}

interface MatAutocompleteSelectedEvent {
  source: MatAutocomplete; // The autocomplete instance that triggered the event
  option: MatOption; // The selected option instance
}

interface MatAutocompleteActivatedEvent {
  source: MatAutocomplete; // The autocomplete instance that triggered the event
  option: MatOption | null; // The activated option (null if no option is active)
}

interface MatAutocompleteTrigger {
  // Panel Control
  openPanel(): void; // Programmatically opens the autocomplete panel
  closePanel(): void; // Programmatically closes the autocomplete panel
  updatePosition(): void; // Updates the position of the open panel

  // State Properties
  panelOpen: boolean; // Whether the autocomplete panel is open
  autocomplete: MatAutocomplete; // Reference to the associated autocomplete component
  optionSelections: Observable<MatAutocompleteSelectedEvent>; // Stream of option selection events

  // Events
  panelClosingActions: Observable<MatAutocompleteSelectedEvent | null>; // Actions that close the panel
}
```

**Usage Example:**

```tsx
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatOptionModule } from '@angular/material/core';

// Basic autocomplete with static options
function BasicAutocompleteExample() {
  const options = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'];

  return (
    <mat-form-field>
      <mat-label>Choose a fruit</mat-label>
      <input
        matInput
        [matAutocomplete]="auto"
        placeholder="Start typing..."
      />
      <mat-autocomplete #auto="matAutocomplete">
        <mat-option *ngFor="let option of options" [value]="option">
          {{ option }}
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  );
}

// Advanced autocomplete with filtering and custom display
@Component({
  template: `
    <mat-form-field>
      <mat-label>Select user</mat-label>
      <input
        matInput
        [formControl]="userControl"
        [matAutocomplete]="userAuto"
        placeholder="Search users..."
      />
      <mat-autocomplete
        #userAuto="matAutocomplete"
        [displayWith]="displayUser"
        [autoActiveFirstOption]="true"
        (optionSelected)="onUserSelected($event)">
        <mat-option
          *ngFor="let user of filteredUsers | async"
          [value]="user">
          <img [src]="user.avatar" class="user-avatar" />
          <span>{{ user.name }}</span>
          <small>{{ user.email }}</small>
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  `
})
export class AdvancedAutocompleteComponent {
  userControl = new FormControl();

  users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com', avatar: 'avatar1.jpg' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', avatar: 'avatar2.jpg' }
  ];

  filteredUsers: Observable<User[]> = this.userControl.valueChanges.pipe(
    startWith(''),
    map(value => this.filterUsers(value || ''))
  );

  displayUser(user: User): string {
    return user ? user.name : '';
  }

  private filterUsers(value: string): User[] {
    if (typeof value !== 'string') return this.users;

    const filterValue = value.toLowerCase();
    return this.users.filter(user =>
      user.name.toLowerCase().includes(filterValue) ||
      user.email.toLowerCase().includes(filterValue)
    );
  }

  onUserSelected(event: MatAutocompleteSelectedEvent): void {
    console.log('Selected user:', event.option.value);
  }
}
```

## Integration Patterns

### Basic Text Filtering

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-label>Country</mat-label>
      <input
        matInput
        [formControl]="countryControl"
        [matAutocomplete]="countryAuto"
      />
      <mat-autocomplete #countryAuto="matAutocomplete">
        <mat-option
          *ngFor="let country of filteredCountries | async"
          [value]="country"
        >
          {{ country }}
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class FilteringAutocompleteComponent {
  countryControl = new FormControl();

  countries: string[] = [
    "United States",
    "Canada",
    "Mexico",
    "United Kingdom",
    "France",
    "Germany",
    "Spain",
    "Italy",
    "Australia",
  ];

  filteredCountries: Observable<string[]> =
    this.countryControl.valueChanges.pipe(
      startWith(""),
      map((value) => this.filterCountries(value || "")),
    );

  private filterCountries(value: string): string[] {
    const filterValue = value.toLowerCase();
    return this.countries.filter((country) =>
      country.toLowerCase().includes(filterValue),
    );
  }
}
```

### Grouped Options

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-label>Pokemon</mat-label>
      <input
        matInput
        [formControl]="pokemonControl"
        [matAutocomplete]="pokemonAuto"
      />
      <mat-autocomplete #pokemonAuto="matAutocomplete">
        <mat-optgroup
          *ngFor="let group of filteredGroups | async"
          [label]="group.type"
        >
          <mat-option *ngFor="let pokemon of group.pokemon" [value]="pokemon">
            {{ pokemon }}
          </mat-option>
        </mat-optgroup>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class GroupedAutocompleteComponent {
  pokemonControl = new FormControl();

  pokemonGroups: PokemonGroup[] = [
    {
      type: "Fire",
      pokemon: ["Charmander", "Charmeleon", "Charizard"],
    },
    {
      type: "Water",
      pokemon: ["Squirtle", "Wartortle", "Blastoise"],
    },
    {
      type: "Grass",
      pokemon: ["Bulbasaur", "Ivysaur", "Venusaur"],
    },
  ];

  filteredGroups: Observable<PokemonGroup[]> =
    this.pokemonControl.valueChanges.pipe(
      startWith(""),
      map((value) => this.filterGroups(value || "")),
    );

  private filterGroups(value: string): PokemonGroup[] {
    if (!value) return this.pokemonGroups;

    const filterValue = value.toLowerCase();
    return this.pokemonGroups
      .map((group) => ({
        type: group.type,
        pokemon: group.pokemon.filter((pokemon) =>
          pokemon.toLowerCase().includes(filterValue),
        ),
      }))
      .filter((group) => group.pokemon.length > 0);
  }
}
```

### Programmatic Control

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-label>Search</mat-label>
      <input
        matInput
        #searchInput
        [matAutocomplete]="searchAuto"
        (focus)="onInputFocus()"
      />
      <button matSuffix mat-icon-button (click)="togglePanel()">
        <mat-icon>{{
          trigger.panelOpen ? "expand_less" : "expand_more"
        }}</mat-icon>
      </button>

      <mat-autocomplete
        #searchAuto="matAutocomplete"
        (opened)="onPanelOpened()"
        (closed)="onPanelClosed()"
      >
        <mat-option *ngFor="let option of searchOptions" [value]="option">
          {{ option }}
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class ProgrammaticAutocompleteComponent implements AfterViewInit {
  @ViewChild("searchInput", { read: MatAutocompleteTrigger })
  trigger: MatAutocompleteTrigger;

  searchOptions: string[] = ["Option 1", "Option 2", "Option 3"];

  ngAfterViewInit() {
    // Set up programmatic control after view initialization
    this.trigger.optionSelections.subscribe((selection) => {
      console.log("Option selected programmatically:", selection.option.value);
    });
  }

  togglePanel(): void {
    if (this.trigger.panelOpen) {
      this.trigger.closePanel();
    } else {
      this.trigger.openPanel();
    }
  }

  onInputFocus(): void {
    // Automatically open panel when input gains focus
    if (!this.trigger.panelOpen) {
      this.trigger.openPanel();
    }
  }

  onPanelOpened(): void {
    console.log("Autocomplete panel opened");
  }

  onPanelClosed(): void {
    console.log("Autocomplete panel closed");
  }
}
```

### Async Data Loading

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-label>Search GitHub users</mat-label>
      <input
        matInput
        [formControl]="searchControl"
        [matAutocomplete]="userAuto"
        placeholder="Enter username..."
      />
      <mat-autocomplete
        #userAuto="matAutocomplete"
        [displayWith]="displayGitHubUser"
      >
        <mat-option *ngFor="let user of filteredUsers | async" [value]="user">
          <img [src]="user.avatar_url" class="github-avatar" />
          <span>{{ user.login }}</span>
          <small *ngIf="user.name">{{ user.name }}</small>
        </mat-option>

        <mat-option *ngIf="isLoading" disabled>
          <mat-spinner diameter="20"></mat-spinner>
          Loading...
        </mat-option>

        <mat-option *ngIf="hasError" disabled>
          Error loading users. Please try again.
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class AsyncAutocompleteComponent {
  searchControl = new FormControl();
  isLoading = false;
  hasError = false;

  filteredUsers: Observable<GitHubUser[]> =
    this.searchControl.valueChanges.pipe(
      startWith(""),
      debounceTime(300),
      distinctUntilChanged(),
      switchMap((value) => this.searchUsers(value || "")),
    );

  constructor(private http: HttpClient) {}

  private searchUsers(query: string): Observable<GitHubUser[]> {
    if (!query.trim()) {
      return of([]);
    }

    this.isLoading = true;
    this.hasError = false;

    return this.http
      .get<{
        items: GitHubUser[];
      }>(`https://api.github.com/search/users?q=${query}`)
      .pipe(
        map((response) => response.items.slice(0, 10)), // Limit to 10 results
        catchError((error) => {
          this.hasError = true;
          return of([]);
        }),
        finalize(() => (this.isLoading = false)),
      );
  }

  displayGitHubUser(user: GitHubUser): string {
    return user ? user.login : "";
  }
}
```

## Best Practices

### Usage Guidelines

- **Implement debounced filtering** - Use `debounceTime()` operator to prevent excessive API calls or filtering operations during rapid typing
- **Limit option count** - Display a reasonable number of options (typically 10-50) to maintain performance and usability
- **Provide meaningful display values** - Use the `displayWith` function to show user-friendly text in the input field after selection
- **Handle loading states** - Show loading indicators for async operations and provide feedback during data fetching
- **Enable keyboard navigation** - Leverage built-in keyboard support (arrow keys, Enter, Escape) for accessibility
- **Use grouped options strategically** - Organize large datasets with `mat-optgroup` for better visual hierarchy and navigation

### Accessibility

- **ARIA support** - The component automatically provides proper ARIA labels, roles, and relationships for screen readers
- **Keyboard navigation** - Full keyboard support with arrow keys for navigation, Enter for selection, and Escape to close
- **Focus management** - Proper focus handling between input field and option list maintains accessibility standards
- **Screen reader announcements** - Options are announced as users navigate through them with assistive technologies
- **High contrast compatibility** - Component styling adapts to high contrast modes for users with visual impairments

### Performance

- **Virtual scrolling** - For large datasets (1000+ options), implement virtual scrolling using `cdk-virtual-scroll-viewport`
- **Lazy loading** - Load options on-demand rather than preloading large datasets in memory
- **Debounced input** - Use `debounceTime()` with 300-500ms delay to optimize filtering and API requests
- **Caching strategies** - Cache frequently accessed data to reduce network requests and improve response times
- **Option limiting** - Restrict displayed options to prevent DOM performance issues with large result sets

## Common Patterns

### Pattern 1: Search with Recent Items

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-label>Search or select recent</mat-label>
      <input matInput [formControl]="searchControl" [matAutocomplete]="auto" />
      <mat-autocomplete #auto="matAutocomplete">
        <mat-optgroup label="Recent" *ngIf="recentItems.length > 0">
          <mat-option *ngFor="let item of recentItems" [value]="item">
            <mat-icon>history</mat-icon>
            {{ item }}
          </mat-option>
        </mat-optgroup>

        <mat-optgroup label="Search Results" *ngIf="filteredResults.length > 0">
          <mat-option *ngFor="let result of filteredResults" [value]="result">
            <mat-icon>search</mat-icon>
            {{ result }}
          </mat-option>
        </mat-optgroup>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class SearchWithRecentComponent {
  searchControl = new FormControl();
  recentItems: string[] = ["Recent Item 1", "Recent Item 2"];
  filteredResults: string[] = [];

  // Implementation combines recent items with search results
}
```

### Pattern 2: Multi-selection with Chips

```tsx
@Component({
  template: `
    <mat-form-field>
      <mat-chip-grid #chipGrid>
        <mat-chip
          *ngFor="let item of selectedItems"
          (removed)="removeItem(item)"
        >
          {{ item }}
          <mat-icon matChipRemove>cancel</mat-icon>
        </mat-chip>

        <input
          [matChipInputFor]="chipGrid"
          [matAutocomplete]="auto"
          [formControl]="itemControl"
          (matChipInputTokenEnd)="addItem($event)"
        />
      </mat-chip-grid>

      <mat-autocomplete
        #auto="matAutocomplete"
        (optionSelected)="selectItem($event)"
      >
        <mat-option
          *ngFor="let option of filteredOptions | async"
          [value]="option"
        >
          {{ option }}
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
  `,
})
export class MultiSelectionAutocompleteComponent {
  itemControl = new FormControl();
  selectedItems: string[] = [];

  filteredOptions: Observable<string[]> = this.itemControl.valueChanges.pipe(
    startWith(""),
    map((value) => this.filterAvailableOptions(value || "")),
  );

  selectItem(event: MatAutocompleteSelectedEvent): void {
    if (!this.selectedItems.includes(event.option.value)) {
      this.selectedItems.push(event.option.value);
      this.itemControl.setValue("");
    }
  }

  private filterAvailableOptions(value: string): string[] {
    // Filter out already selected items and apply search filter
    return this.allOptions
      .filter((option) => !this.selectedItems.includes(option))
      .filter((option) => option.toLowerCase().includes(value.toLowerCase()));
  }
}
```
