# Sort Component

## Overview

### Purpose

Use this component to generate sort functionality

### When to Use

Sort functionality is essential for organizing and navigating data in your Angular application. Use the Sort component in these scenarios:

- **Data Tables**: Enable users to sort table columns by different criteria (alphabetical, numerical, date-based)
- **List Interfaces**: Allow sorting of list items based on various properties
- **Data Grids**: Provide sorting capabilities for complex data presentation layouts
- **Search Results**: Enable users to organize search results by relevance, date, or other metrics
- **Dashboard Content**: Sort widgets, reports, or data cards by priority or custom criteria
- **File Listings**: Sort files by name, size, date modified, or type
- **User Management**: Sort user lists by name, role, last activity, or registration date

### Architecture

**No Coupling**: This is a standalone component that can be used independently. While commonly used with tables, MatSort can be applied to any sortable data structure and works through directives and event handling.

### Component Interdependencies

MatSort is designed to work independently but integrates seamlessly with:

- **MatTable**: Most common integration for table column sorting
- **MatSortHeader**: Directive for making column headers sortable
- **Custom Components**: Can be integrated with any component through event binding

## Components

### MatSort {Standalone Component}

**Purpose:** Provides sorting functionality and state management for sortable data. Acts as a controller that manages sort state, direction, and emits sort change events.

**Interface:**

```typescript
interface MatSort {
  // Sort state properties
  active: string; // ID of the currently sorted column
  direction: SortDirection; // Current sort direction: 'asc', 'desc', or ''
  start: SortDirection; // Initial sort direction when first sorted: 'asc' or 'desc'

  // Control properties
  disabled: boolean; // Whether sorting is disabled
  disableClear: boolean; // Whether to disable clearing sort by cycling through directions

  // Events
  sortChange: EventEmitter<Sort>; // Emitted when sort state changes

  // Methods
  sort(sortable: MatSortable): void; // Programmatically sort a column
  getNextSortDirection(sortable: MatSortable): SortDirection; // Get next direction in cycle
}

interface Sort {
  active: string; // The name of the column being sorted
  direction: SortDirection; // The sort direction
}

type SortDirection = "asc" | "desc" | "";
```

**Usage Example:**

```typescript
import { Component, ViewChild, AfterViewInit } from "@angular/core";
import { MatSort, Sort } from "@angular/material/sort";
import { MatTableDataSource } from "@angular/material/table";

@Component({
  selector: "app-sortable-data",
  template: `
    <div>
      <p>Current sort: {{ currentSort }}</p>
      <table mat-table [dataSource]="dataSource" matSort>
        <!-- Define your columns with mat-sort-header -->
        <ng-container matColumnDef="name">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Name</th>
          <td mat-cell *matCellDef="let element">{{ element.name }}</td>
        </ng-container>

        <ng-container matColumnDef="age">
          <th mat-header-cell *matHeaderCellDef mat-sort-header>Age</th>
          <td mat-cell *matCellDef="let element">{{ element.age }}</td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>
      </table>
    </div>
  `,
})
export class SortableDataComponent implements AfterViewInit {
  @ViewChild(MatSort) sort!: MatSort;

  displayedColumns: string[] = ["name", "age"];
  dataSource = new MatTableDataSource([
    { name: "John", age: 30 },
    { name: "Alice", age: 25 },
    { name: "Bob", age: 35 },
  ]);

  currentSort = "";

  ngAfterViewInit() {
    this.dataSource.sort = this.sort;

    // Listen to sort changes
    this.sort.sortChange.subscribe((sortState: Sort) => {
      this.currentSort = `${sortState.active} ${sortState.direction}`;
    });
  }
}
```

## Integration Patterns

### Basic Usage

```typescript
import { MatSortModule } from "@angular/material/sort";
import { MatTableModule } from "@angular/material/table";

// Simple sortable table
@Component({
  template: `
    <table mat-table [dataSource]="data" matSort>
      <ng-container matColumnDef="title">
        <th mat-header-cell *matHeaderCellDef mat-sort-header>Title</th>
        <td mat-cell *matCellDef="let item">{{ item.title }}</td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="columns"></tr>
      <tr mat-row *matRowDef="let row; columns: columns"></tr>
    </table>
  `,
})
export class BasicSortExample {
  columns = ["title"];
  data = [{ title: "Zebra" }, { title: "Apple" }, { title: "Banana" }];
}
```

### Advanced Usage

```typescript
// Custom sorting with programmatic control
@Component({
  template: `
    <div>
      <button (click)="sortByName()">Sort by Name</button>
      <button (click)="sortByDate()">Sort by Date</button>
      <button (click)="clearSort()">Clear Sort</button>

      <table
        mat-table
        [dataSource]="dataSource"
        matSort
        (matSortChange)="onSortChange($event)"
      >
        <ng-container matColumnDef="name">
          <th
            mat-header-cell
            *matHeaderCellDef
            mat-sort-header
            [disabled]="sortingDisabled"
            arrowPosition="before"
          >
            Name
          </th>
          <td mat-cell *matCellDef="let item">{{ item.name }}</td>
        </ng-container>

        <ng-container matColumnDef="date">
          <th mat-header-cell *matHeaderCellDef mat-sort-header start="desc">
            Date
          </th>
          <td mat-cell *matCellDef="let item">{{ item.date | date }}</td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>
      </table>
    </div>
  `,
})
export class AdvancedSortExample implements AfterViewInit {
  @ViewChild(MatSort) sort!: MatSort;

  displayedColumns = ["name", "date"];
  sortingDisabled = false;

  dataSource = new MatTableDataSource([
    { name: "John", date: new Date("2023-01-15") },
    { name: "Alice", date: new Date("2023-03-20") },
    { name: "Bob", date: new Date("2023-02-10") },
  ]);

  ngAfterViewInit() {
    this.dataSource.sort = this.sort;
  }

  sortByName() {
    this.sort.sort({ id: "name", start: "asc", disableClear: false });
  }

  sortByDate() {
    this.sort.sort({ id: "date", start: "desc", disableClear: false });
  }

  clearSort() {
    this.sort.active = "";
    this.sort.direction = "";
    this.sort.sortChange.emit({ active: "", direction: "" });
  }

  onSortChange(sortState: Sort) {
    console.log("Sort changed:", sortState);
  }
}
```

### Common Variations

```typescript
// Custom sort with non-table elements
@Component({
  template: `
    <div>
      <div matSort (matSortChange)="sortData($event)">
        <button mat-sort-header="name" class="sort-button">Sort by Name</button>
        <button mat-sort-header="price" class="sort-button">
          Sort by Price
        </button>
      </div>

      <div class="items-grid">
        <div *ngFor="let item of sortedItems" class="item-card">
          <h3>{{ item.name }}</h3>
          <p>{{ item.price | currency }}</p>
        </div>
      </div>
    </div>
  `,
  styles: [
    `
      .sort-button {
        margin: 0 8px;
      }
      .items-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
        margin-top: 16px;
      }
      .item-card {
        border: 1px solid #ddd;
        padding: 16px;
        border-radius: 4px;
      }
    `,
  ],
})
export class CustomSortExample {
  items = [
    { name: "Laptop", price: 999 },
    { name: "Phone", price: 599 },
    { name: "Tablet", price: 399 },
  ];

  sortedItems = [...this.items];

  sortData(sort: Sort) {
    if (!sort.active || sort.direction === "") {
      this.sortedItems = [...this.items];
      return;
    }

    this.sortedItems = this.items.slice().sort((a, b) => {
      const isAsc = sort.direction === "asc";
      const valueA = a[sort.active as keyof typeof a];
      const valueB = b[sort.active as keyof typeof b];

      if (typeof valueA === "string" && typeof valueB === "string") {
        return isAsc
          ? valueA.localeCompare(valueB)
          : valueB.localeCompare(valueA);
      }

      return isAsc ? (valueA < valueB ? -1 : 1) : valueA > valueB ? -1 : 1;
    });
  }
}
```

## Best Practices

### Usage Guidelines

- **Initialize sorting after view init**: Always set up MatSort in `ngAfterViewInit()` to ensure proper DOM initialization
- **Provide clear visual feedback**: Use `mat-sort-header` for obvious sorting indicators and arrow positioning
- **Handle empty states**: Consider how sorting should behave with empty or null values in your data
- **Set appropriate default directions**: Use `start="desc"` for date columns or numeric values where descending order is more meaningful
- **Disable sorting when appropriate**: Set `disabled` property when data is loading or when sorting doesn't make sense for certain columns

### Accessibility

- **Keyboard navigation**: MatSort provides built-in keyboard support (Enter/Space to toggle sort)
- **Screen reader announcements**: Sort state changes are automatically announced to assistive technologies
- **Focus management**: Proper focus indicators for sort headers
- **Aria attributes**: Automatic ARIA labels describe sort state ("sorted ascending", "sorted descending", etc.)

### Performance

- **Efficient data structures**: Use MatTableDataSource for automatic sorting with large datasets
- **Virtual scrolling**: Combine with CDK Virtual Scrolling for very large datasets
- **Debounce rapid changes**: Consider debouncing if implementing real-time sorting with user input
- **Optimize comparators**: Write efficient comparison functions for complex data types

## Common Patterns

### Pattern 1: Table Integration

```typescript
// Standard table with multiple sortable columns
@Component({
  template: `
    <mat-table [dataSource]="dataSource" matSort class="mat-elevation-z2">
      <ng-container matColumnDef="id">
        <mat-header-cell *matHeaderCellDef mat-sort-header>ID</mat-header-cell>
        <mat-cell *matCellDef="let element">{{ element.id }}</mat-cell>
      </ng-container>

      <ng-container matColumnDef="name">
        <mat-header-cell *matHeaderCellDef mat-sort-header
          >Name</mat-header-cell
        >
        <mat-cell *matCellDef="let element">{{ element.name }}</mat-cell>
      </ng-container>

      <ng-container matColumnDef="status">
        <mat-header-cell *matHeaderCellDef mat-sort-header
          >Status</mat-header-cell
        >
        <mat-cell *matCellDef="let element">
          <mat-chip [color]="element.status === 'active' ? 'primary' : 'warn'">
            {{ element.status }}
          </mat-chip>
        </mat-cell>
      </ng-container>

      <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
      <mat-row *matRowDef="let row; columns: displayedColumns"></mat-row>
    </mat-table>
  `,
})
export class TableSortPattern {
  displayedColumns = ["id", "name", "status"];
  dataSource = new MatTableDataSource([
    { id: 1, name: "John Doe", status: "active" },
    { id: 2, name: "Jane Smith", status: "inactive" },
    { id: 3, name: "Bob Johnson", status: "active" },
  ]);
}
```

### Pattern 2: Custom Data Source

```typescript
// Custom sorting implementation for complex data
@Component({
  template: `
    <div matSort (matSortChange)="sortData($event)">
      <mat-card *ngFor="let user of sortedUsers" class="user-card">
        <mat-card-header>
          <mat-card-title>{{ user.name }}</mat-card-title>
          <mat-card-subtitle>{{ user.department }}</mat-card-subtitle>
        </mat-card-header>
        <mat-card-content>
          <p>Joined: {{ user.joinDate | date }}</p>
          <p>Projects: {{ user.projectCount }}</p>
        </mat-card-content>
      </mat-card>

      <div class="sort-controls">
        <button mat-button mat-sort-header="name">Sort by Name</button>
        <button mat-button mat-sort-header="joinDate">Sort by Join Date</button>
        <button mat-button mat-sort-header="projectCount">
          Sort by Projects
        </button>
      </div>
    </div>
  `,
  styles: [
    `
      .user-card {
        margin: 8px 0;
      }
      .sort-controls {
        position: sticky;
        top: 0;
        background: white;
        padding: 16px;
        border-bottom: 1px solid #ddd;
      }
    `,
  ],
})
export class CustomDataSourcePattern {
  users = [
    {
      name: "Alice Johnson",
      department: "Engineering",
      joinDate: new Date("2022-01-15"),
      projectCount: 5,
    },
    {
      name: "Bob Smith",
      department: "Design",
      joinDate: new Date("2021-08-20"),
      projectCount: 3,
    },
    {
      name: "Charlie Brown",
      department: "Marketing",
      joinDate: new Date("2023-02-10"),
      projectCount: 7,
    },
  ];

  sortedUsers = [...this.users];

  sortData(sort: Sort) {
    if (!sort.active || sort.direction === "") {
      this.sortedUsers = [...this.users];
      return;
    }

    this.sortedUsers = this.users.slice().sort((a, b) => {
      const isAsc = sort.direction === "asc";

      switch (sort.active) {
        case "name":
          return this.compare(a.name, b.name, isAsc);
        case "joinDate":
          return this.compare(
            a.joinDate.getTime(),
            b.joinDate.getTime(),
            isAsc,
          );
        case "projectCount":
          return this.compare(a.projectCount, b.projectCount, isAsc);
        default:
          return 0;
      }
    });
  }

  private compare(
    a: string | number,
    b: string | number,
    isAsc: boolean,
  ): number {
    return (a < b ? -1 : 1) * (isAsc ? 1 : -1);
  }
}
```
